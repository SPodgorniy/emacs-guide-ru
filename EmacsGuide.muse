#title Программирование Emacs для редактирования и рефакторинга кода
#keywords c, c++, emacs, cedet, programming, semantic, ede, программирование, ide, integrated development environment, java, refactoring

В пособии показаны основы редактора Emacs, начала програм-мирования на Emacs Lisp; разобраны несколько примеров скриптов и наиболее часто употребляемые функции. Особый акцент сделан на применении Emacs Lisp для разработки программ автома-тизированного рефакторинга кода.

<contents>

* Благодарности

Авторы выражают благодарность всем, кто помогал им в работе: компании Epam System за поддержку в создании пособия; Амине Идиговой и Руслану Щуцкому за дизайн, верстку и печать книги; Василию Ременюку за организацию встречи любителей функционального программирования (scala.by), для которой и было написано это пособие.

* К читателю

Друг, ты держишь в руках первое издание книги о программировании Emacs. Мы надеемся, что в будущем сможем добавить много материала и выпустить новое издание. С твоей помощью мы можем сделать его лучше! Если ты заметил ошибку, или хочешь предложить свой скрипт, тему или даже главу – напиши об этом авторам. Мы будем тебе признательны!

Дмитрий Бушенко ([[mailto:d.bushenko@gmail.com][d.bushenko@gmail.com]]), Алекс Отт ([[mailto:alexott@gmail.com][alexott@gmail.com]])

* Введение

Большая часть времени программиста занята написанием и редактированием программного кода. Существует множество инструментов, позволяющих быстро разрабатывать программный продукт, автоматизировать типовые задачи, проводить рефакторинг. Среди них – известные среды интегрированной разработки, сложные текстовые редакторы и консольные утилиты. Каждый из этих инструментов позволяет легко решать свой собственный класс задач. Здесь мы будем рассматривать только задачу автоматизированного редактирования и рефакторинга кода.

Сравнивая возможности современных IDE, таких как MS Visual Studio, Eclipse, Netbeans, Idea, легко заметить, что они обладают схожей функциональностью. У них есть сниппеты и средства автоматического рефакторинга, например, переименование класса или инкапсуляция члена класса в аксессоре. Это очень хорошие средства, зачастую они покрывают большую часть потребностей программиста. Но что делать, если появились задачи, для которых в IDE еще нет решения?

Сложные задачи, для которых пока нет готовых инструментов, чаще всего возникают на переднем крае Computer Science. Они появляются вместе с новыми языками программирования и экспериментальными технологиями. Больше всего нетипичных задач у любителей немейнстримных языков программирования, таких как Clojure, Scala, Haskell и т.д.

Что же делать, если вы пользуетесь новейшими языками и технологиями, а ваш любимый текстовый редактор заставляет писать массу кода вручную? Разумеется, выбрать такой редактор, который может автоматизировать повторяющиеся задачи!

В этом пособии мы вкратце рассмотрим возможности текстового редактора GNU Emacs, позволяющие автоматизировать рутину. Emacs – программируемый текстовый редактор, именно поэтому он идеально подходит для решения нетипичных задач. Если в нем не хватает какой-то возможности, то ее всегда можно добавить самостоятельно.

Emacs написан, в основном, на языке Emacs Lisp (далее – elisp). Мы воспользуемся этим языком для того, чтобы реализовать нужные нам функции текстового редактора. Поначалу это, конечно, может показаться сложным делом. Но усилия, потраченные на изучение Emacs и elisp, впоследствии окупятся.

* Коротко о GNU Emacs

Emacs -- программа с длиной историей. Еще недавно существовало несколько популярных ее разновидностей (XEmacs, SXEmacs, GNU Emacs), но в настоящее время, самой активно развивающейся является GNU Emacs. Стабильной версией GNU Emacs является версия 23. Но мы рекомендуем использовать бета-версии GNU Emacs 24, в которой реализовано много новинок, включая пакетный менеджер, и многое другое. Пользователи Linux могут найти сборки для своих дистрибутивов, например, [[http://emacs.naquadah.org/][для Debian & Ubuntu]]. Пользователи Windows могут получить [[http://alpha.gnu.org/gnu/emacs/windows/][бинарную сборку]].

При запуске, Emacs читает свою конфигурацию из файла =~/.emacs.d/init.el= (или из =~/.emacs=, если он существует). Эта конфигурация является программой на Emacs и описывает какие пакеты должны быть загружены, переменные выставлены и т.п. Но вначале, вам не обязательно все писать самим -- можете начать с адаптации существующих конфигураций, например, из проекта [[https://github.com/technomancy/emacs-starter-kit][Emacs Starter Kit]], который был [[http://zahardzhan.github.com/2010/emacs-starter-kit-the-program.html][описан на русском языке]]. Просто следуйте описанным шагам.

Поведение Emacs можно настраивать почти не зная Emacs Lisp -- используя механизм Customize. Имеется несколько команд для установки значений переменных, шрифтов (faces) и т.п. Самыми популярными являются команды  =customize-variable=, =customize-group= &  =customize-face=. Эти команды можно запустить при помощи сочетания клавиш =M-x <команда>= (=M-= -- это клавиша =Meta=, которая часто привязана к клавише =Alt= на стандартных клавиатурах), затем задайте имя переменной или группы переменных (используйте клавишу =TAB= для дополнения имен).

Подробней о работе с Emacs вы можете в руководстве (есть и русская версия, но она для версии 20.x), которое идет вместе с ним, или в [[http://alexott.net/ru/writings/altlinux-emacs/index.html][следующей статье]].

** Получение справки и поиск информации

В поставке GNU Emacs имеется вся информация необходимая для начала работы с ним и его программирования. Для начинающих пользователей будет полезен учебник Emacs (вызываемый сочетанием клавиш =C-h t= (сначала нажать =Control-h=, потом =t=)), переведенный на разные языки, в том числе и на русский. Подробные руководства по Emacs & Emacs Lisp (а также многим другим пакетам и программам) поставляются в формате info, и вы можете обратиться к ним через меню или набрав сочетание =C-h i=.

Кроме того, вы можете получить подробную информацию о переменных (текущее значение, описание) с помощью команды =describe-variable= (=C-h v=), функциях (описание, где определена) -- клавиши (=C-h f=) и текущем режиме (сочетание клавиш =C-h m=).

** Буфера, пакеты, режимы

Практически вся функциональность Emacs (кроме низкоуровневых модулей) реализована на Emacs Lisp. В состав дистрибутива входит огромное количество пакетов расширений. Начиная с версии 24, в состав Emacs входит менеджер пакетов, который используется для установки "внешних" пакетов, в основном это release-версии. Если же вы хотите использовать bleeding edge-версии, то можете ставить пакеты сами (правда их потом неудобно поддерживать), либо воспользоваться [[https://github.com/dimitri/el-get][пакетом el-get]], который автоматизирует установку и поддержание пакетов в актуальном состоянии.

Работа с текстом происходит в буферах Emacs, которые обычно связаны с файлами на диске. Каждый буфер имеет один основной (major) режим, который определяет, как текст будет редактироваться, и может также иметь несколько дополнительных (minor) режимов. Например, основными режимами являются режимы для редактирования исходного кода на C/C++, Java, Clojure, Scala и т.д., а дополнительными режимами являются режим подсветки ключевых слов (font-lock), проверки орфографии и т.д. Посмотреть список включенных режимов для текущего буфера можно при помощи сочетания клавиш =C-h m= (вам также будут показаны все keybindings -- имеющиеся сочетания клавиш, и команды к ним привязанные). Обычно основные режимы включаются автоматически, в зависимости от расширения файла, но вы можете включить их явно с помощью =M-x <name-mode>= (например, =M-x clojure-mode=) или изменив маппинг между именем файла и режимом, например:

<src lang="emacs-lisp">
(add-to-list 'auto-mode-alist '("\\.ipp$" . c++-mode))
</src>

Режимы могут иметь собственные настройки, обычно это переменные и хуки (набор функций, которые будут вызваны при включении режима). Переменные могут быть глобальными -- общими для всех буферов, и локальными -- специфическими для конкретных буферов. Обычно в описании переменных (сочетание =C-h v=) можно увидеть -- локальная эта переменная или глобальная. Глобальные переменные устанавливаются либо через =M-x customize-variable=, либо с помощью =setq= из Emacs Lisp. А локальные переменные в основном устанавливаются из хуков.

Хук (hook) -- это набор функций без аргументов, которые будут вызваны при включении режима (открытии файла, или создании буфера, или явном включении режима). Для каждого режима вы можете определить множество таких функций, которые будут вызваны по очереди. Обычно с помощью таких хуков устанавливаются значения для локальных переменных, локальные привязки клавиш, дополнительные режимы и т.п. Функции добавляются в хук с помощью функции =add-hook=, а удаляются с помощью =remove-hook= (удаление хуков – редко встречающаяся операция). Например:

<src lang="emacs-lisp">
(defun common-hook ()
  (local-set-key"\C-c:" 'uncomment-region)
  (local-set-key"\C-c;" 'comment-region)
  (local-set-key"\C-c\C-c" 'comment-region)
  (font-lock-mode 1))
(add-hook 'emacs-lisp-mode-hook 'common-hook)

(defun elisp-mode-hook ()
  ;; set local variables
  (setq indent-tabs-mode </span><span class="c0 c25">t)
  ;; enable minor modes
  (turn-on-eldoc-mode)
  (paredit-mode 1)
  ;; bind local keys
  (local-set-key [(control c) /] 'semantic-ia-complete-symbol))
(add-hook 'emacs-lisp-mode-hook 'elisp-mode-hook)
</src>

* Основы Emacs Lisp

** Lisp, формы, списки и префиксная нотация

В elisp объект, который может быть "вычислен" (получено значение для него), называют формой. Имеется три вида форм: 
 - символ[1] -- объект с уникальным именем, при вычислении которого (в зависимости от контекста), мы либо получаем значение, связанное с символом, либо вызываем функцию, которая сохранена в функциональном слоте символа;
 - список -- набор форм, заключенный в скобки, где первый элемент списка определяет подтип формы -- функция, макрос или специальная форма;
 - остальные формы, вычисляемые сами в себя (self-evaluating forms) -- числа, строки, буквы.

Список, содержащий код, по сути, ничем не отличается от списка, содержащего данные. Интерпретатор Lisp-а считает первый элемент списка – вызовом функции (или специальной формы, или макроса), а остальные элементы – параметрами функции.

Например, список =(+ 2 3 4)= является вызовом функции =+= с параметрами =2=, =3=, =4= и будет вычислен как =9=. Такая запись вызова функции называется *префиксной*.

Практически все -- математические операции, работа с файлами и т.п. -- это обычные функции, точно такие же, какие будем писать далее в этом пособии. Помимо функций имеются также специальные формы -- примитивные функции, параметры которых не вычисляются в момент вызова. Это поведение отличается от обычных функций, аргументы которых вычисляются до вызова функции. Сюда относятся =if=, =cond=, =defun=, =defvar=, =let=, =and=, и т.д. А макросы -- функции, выполняющиеся во время компиляции кода, позволяют генерировать код, который затем будет выполнен.

Интерпретатор Lisp-а не будет вычислять форму, перед которой стоит кавычка[2], т.к. считается, что это данные. Например, если мы запишем ='(+ 2 2)=, то для интерпретатора этот список останется списком, а не вычислится в число =4=.

** Как писать программы на Emacs Lisp

*** Динамическое вычисление кода (eval)

Скрипты Emacs можно писать и вычислять[3] (</span> =eval= <span>) в любом открытом буфере, в котором включен режим =emacs-lisp=, независимо от его содержания. Например, откройте буфер *scratch*[4] и напишите функцию =hello=.

(defun hello ()
  "Hello world function"
  (interactive)
  (message"Hello, World!"))

Для того чтобы вычислить этот код, необходимо поставить курсор после самой последней скобки функции и нажать комбинацию =C-x C-e= (функция =eval-last-sexp=). Кроме того, вы можете вычислить этот код с помощью функции =eval-defun=, которая привязана к клавишам =C-M-x=, при этом вы можете находиться в любой точке этой функции.

Выполнить функцию  =hello=  можно тем же способом, что и любые другие команды Emacs: =M-x hello=[5]. 

Справка по этой функции, как и по другим, доступна по комбинации =C-h f <function name>=.

*** Функции и команды

Emacs различает два типа функций: «чистые функции», возвращающие какой-то результат, и команды (интерактивные функции), выполняемые при помощи =M-x= в основном ради побочных эффектов. Технически, команды отличаются от простых функций только вызовом =(interactive)=. Если вы хотите выполнить вашу функцию при помощи =M-x=, то в ней обязательно должен присутствовать вызов =(interactive)=.

*** Загрузка и выполнение скриптов

Как правило, скрипты Emacs хранятся в каталоге =$HOME/.emacs.d/= в файлах с  расширением =.el=.

Загрузка и компиляция выполняется командой =load-file=. При выполнении этой команды необходимо задать имя загружаемого файла, после чего Emacs скомпилирует указанный скрипт. Функции и команды из этого скрипта сразу же станут доступны пользователю.

** Типы данных

Emacs Lisp поддерживает стандартный набор типов. К базовым типам относятся:
 - логические значения -- =nil= используется для обозначения *false*, и =t= -- для обозначения *true*. На самом деле, =nil= также обозначает и пустой список =()=, и взаимозаменяем с ним в условных операторах. А вместо  =t= может использоваться любое не-=nil= значение -- число, строка, не-пустой список и т.д.;
 - целые числа в диапазоне -2^29 до 2^29, (2 бита отведено для поля типа объекта);
 - числа с плавающей точкой -- стандартный double из C;
 - буквы (character) -- записываются как =?S= для обычных букв и цифр, =?\n=, =?\t=, =?\\= и т.д. -- для стандартных последовательностей, или =?\NNN=, =?\xNN= для записи символа в 8- или 16-ричной системе исчисления. Поддерживается и Unicode с помощью записи =?\uNNNN=;
 - строки - набор букв, записанный в двойных кавычках;
 - точечная пара (cons cell) и списки -- основные типы для "сложных структур данных". Точечная пара -- объект состоящий из 2-х слотов, с традиционными названиями =car=  и =cdr=. Точечная пара записывается как =(val1 . val2)=. Списки в свою очередь строятся на основе точечных пар, где =cdr= указывает на следующий элемент списка, так что список =(1 2 3)= можно рассматривать как набор точечных пар следующего вида: =(1 . (2 . (3 . nil)))=. Список может содержать элементы разных типов. Имеется также специальная запись для так называемых ассоциативных списков, где каждый элемент является точечной парой, представляющей собой ключ/значение. Например, =((rose . red) (lily . white) (buttercup . yellow))=[6];
 - массивы -- также как и в других языках программирования, массивы обеспечивают константную скорость доступа к элементам. Вариантами массивов являются вектора, строки и т.п. типы.

Помимо базовых типов данных при программировании на Emacs Lisp часто используются сложные объекты, которые стоит упомянуть:
 - точка (point) -- это место в буфере, в котором происходит вставка или удаление данных. Она же обозначается курсором в активном буфере. Каждый буфер всегда имеет точку, даже если он не активен.
 - метка (mark) -- это специальная позиция, которая указывает на конец выделенной области. Вторым концом области является текущая точка. Стоит отметить, что даже если выделение снято, то метка все равно остается, пока не будет сделано новое выделение текста.
 - область (region) -- выделенный текст в буфере, ограниченный точкой и меткой. Пользователь может выполнять различные команды над выделенной областью.
 - буфер -- объект содержащий текст, чаще всего это данные из файла на диске, но не обязательно. В каждый момент времени может существовать только один активный буфер, но вы можете переключаться и в другие буфера по необходимости. Каждый буфер имеет набор связанных с ним данных - точка и маркер, локальные переменные и т.д. Обычно буфер содержит текст, так что вы можете манипулировать им, также как и при работе с обычными строками.

В некоторых случаях ваш код должен работать с данными разных типов, так что в этих случаях вам нужны функции проверки типов. В соответствии со стандартами программирования на Emacs Lisp, функции предикаты имеют имена, оканчивающиеся на `<code>p</code>', так что вы можете найти функцию проверки типа путем добавления `<code>p</code>' к названию типа -- =listp=,  =integerp=, =symbolp=, =bufferp=, и т.д. Кроме того, вы можете получить символ, описывающий заданный объект с помощью функции =type-of=.

** Символы и переменные

В Emacs, как и в других Lisp'ах, имеется понятие символа (symbol) -- объекта с уникальным именем. Каждый символ имеет четыре компонента -- печатное имя, значение (value), связанную функцию и список свойств (property list). Определение символов производится с помощью различных выражений, которые определяют как этот символ будет использоваться[7]. =defvar= &  =defconst= определяют символ как глобальную переменную  или константу[8]. 

Но в Emacs Lisp объявление переменных не является обязательным, так что вы можете создавать их с помощью специальной формы </span> =setq= <span>, которая присваивает значение символу (или нескольким символам[9]).

<src lang="emacs-lisp">
(setq a 17)
(setq s "Hello!")
</src>

что эквивалентно:

<src lang="emacs-lisp">
(defvar a 17)
(defvar s "Hello!")
</src>

Переменные =a= и =s= будут объявлены глобальными, только если их значения не устанавливаются внутри области видимости локальных =a= и =s=. В случае если в функции уже объявлены =a= или =s= > как параметры либо как локальные переменные внутри =let=, то =setq= изменит значения именно этих, локальных, переменных.

Локальные переменные объявляются при помощи функций =let= и =let*=:
<src lang="emacs-lisp">
(let (a b (c 3))
  (setq a 1 
        b 2)
  (message (number-to-string (+ a b c))))
</src>

Оператор =let= действует примерно как фигурные скобки в java: создает новую область видимости. =let= создает переменные, действующие только в этой области, здесь -- =a= и =b=; изначально они содержат значение =nil=. Если переменную нужно инициализировать некоторым значением, то имя переменной и значение нужно взять в скобки, как здесь значение =3= присвоено переменной =с=. По умолчанию, на переменные объявленные в =let= нельзя ссылаться в этом же списке инициализации, для этого имеется форма =let*=. Например, вот этот код не будет работать:
<src lang="emacs-lisp">
(let ((a 2)
      (b (+ a 2)))
  ...)
</src>

а вот этот, будет:
<src lang="emacs-lisp">
(let* ((a 2)
       (b (+ a 2)))
  ...)
</src>

Локальным переменным =a= и =b= присваивает значения оператор =setq=[10]. Функция =message= выведет в минибуфере любую строку. Для того чтобы результат суммы переменных =a=, =b= и =c= перевести в строку здесь используется функция =number-to-string=.

Все тело выражения =let= можно выполнить при помощи =C-x e= так же, как до этого мы компилировали elisp-функции.

Параметры функций задаются в скобках после названия функции[11].

<src lang="emacs-lisp">
(defun plus (a b)
  (interactive)
  (message (number-to-string (+ a b))))
</src>

Достаточно часто возникает задача сравнения значений переменных, и для этого имеется набор функций, как общих, так и специализированных для конкретных типов. К общим функциям относятся:
 - =(eq obj1 obj2)= -- возвращает =t= если =obj1= и =obj2= являются одним и тем же объектом, целым числом с одинаковым значением, или пустой строкой;
 - =(eql obj1 obj2)= -- аналогично eq, но также работает и для чисел с плавающей точкой;
 - =(equal obj1 obj2)= -- возвращает =t= если =obj1= и =obj2= имеют одинаковые компоненты, что позволяет использовать ее для сравнения списков, строк и других объектов.

К специализированным функциям сравнения относятся:
 - <code>==</code>, <code>/=</code>, <code><</code>, <code>></code>, <code><=</code>, <code>>=</code> -- для сравнения чисел;
 - =char-equal=, <code>string=</code>, <code>string<</code> -- для сравнения строк и букв;

** Объявление функций

Есть два способа объявить функцию. Первый, как мы уже видели ранее, при помощи =defun=:
<src lang="emacs-lisp">
(defun <function-name> (<parameters>)
<documentation string>
<body>)
</src>

Второй способ -- при помощи макроса =lambda= создать анонимную функцию.
<src lang="emacs-lisp">
(lambda ()
<documentation string>
<body>)
</src>

Результатом вычисления будет тело самой функции. Поскольку никакого имени ей не присваивается, то лямбда функцию можно либо сохранить в символе при помощи =setq=, либо вызвать ее в =funcall= или =mapcar=.
<src lang="emacs-lisp">
(setq l-hello (lambda () 
                 (message"Hello, World!")))

(defun hello2 ()
  (interactive)
  (funcall l-hello))
</src>

** Управление ходом программы

*** (progn <тело>)

Последовательно выполняет все функции, переданные =progn= в качестве параметров. Возвращает результат выполнения последней функции. Используется везде, где нужно вместо одного выражения выполнить несколько, например, из-за побочных эффектов[12].

*** (if <условие> <тогда> <иначе>)

Специальная форма =if= работает так же, как и в любом другом языке программирования. Параметр =<иначе>= является необязательным.

<src lang="emacs-lisp">
(let ((a 5) b)
  (if (> a 0)
      (progn
        (setq b 17)
        (message (number-to-string b)))
      (message "The ELSE branch")))
</src>

В данном примере локальной переменной =а= <span> присваивается значение =5=, объявляется локальная переменная =b=. В условии =if= проверяется, является ли =a= положительным числом. Если да, то выполняется последовательность функций: 1) переменной =b= присваивается значение =17=; 2) выводится в минибуфер значение переменной =b=. Иначе выводится строка «The ELSE branch».

*** (cond <clause>)

=cond= работает по тому же принципу, что и switch/case в Java, но ветвление производится по произвольному предикату, а не по фиксированному значению. Пример:
<src lang="emacs-lisp">
(let ((a 5))
  (cond
   ((> a 0) (message"Positive"))
   ((= a 0) (message"Zero"))
   ((< a 0) (message"Negative"))))
</src>

**Примечание**: строки и списки нужно сравнивать функцией =equal=.

*** (while <условие> <тело-цикла>)

Специальная форма =while= работает также как и в любом другом языке программирования.
<src lang="emacs-lisp">
(let ((s"") 
      (i 0))
  (while (< i 10)
    (setq s (concat s (number-to-string i)))
    (setq i (1+ i)))
  (message s))
</src>

После выполнения данного примера будет выведена строка «0123456789».

*** (dotimes (<переменная> <число> [результат]) <тело>)

Предыдущий пример можно переписать следующим образом:
<src lang="emacs-lisp">
(let ((s""))
  (dotimes (i 10)
    (setq s (concat s (number-to-string i))))
  (message s))
</src>

Возвращаемое значение из =dotimes= -- =[результат]= или =nil=, если =[результат]= не задан.

*** (dolist  (<переменная> <список> [результат]) <тело>)

Еще один способ выполнить конкатенацию всех цифр от 0 до 9 -- задать их в списке. Функция =dolist= работает как =foreach= (формат вызова примерно такой же, как у =dotimes=):
<src lang="emacs-lisp">
(let ((s""))
  (dolist (i '(0 1 2 3 4 5 6 7 8 9))
    (setq s (concat s (number-to-string i))))
  (message s))
</src>

Здесь список цифр от 0 до 9 не является вызовом функции, т.к. перед ним стоит одинарная кавычка. 

*** do, do*

Макрос </span> =do= <span> -- одна из самых сложных в этой главе. Выглядит он так:
<src lang="emacs-lisp">
(do (<объявление-переменных>)
    (<условия-выхода-из-цикла>)
    <вызовы-функций>)
</src>

Обратите внимание: секции «объявление переменных» и «условия выхода из цикла» -- это списки. Поэтому, даже если переменная всего одна, и условие выхода только одно, все равно их нужно заключать в дополнительные скобки.

Вот как выглядит предыдущий пример с конкатенацией цифр при помощи функции do:
<src lang="emacs-lisp">
(let ((s""))
  (do ((i 0 (1+ i)))
      ((equal i 9))
      (setq s (concat s (number-to-string i))))
  (message s))
</src>

Первый параметр -- список объявлений переменных, каждое из которых также является списком. Здесь объявляется переменная =i=, начальное значение -- =0=, функция для изменения значения переменной =i= -- =(1+ i)=.

Второй параметр -- список условий выхода из цикла. Каждое условие -- вызов какой-либо функции. Поскольку этот вызов -- также является списком, то условие выхода из цикла выглядит =((equal i 9))=.

Последний параметр -- тело цикла. Здесь -- это конкатенация цифр и сохранение значения в переменной =s=.

Функция =do*= отличается от =do= тем же, чем =let*= от =let=.

*** loop

Макрос =loop= имеет довольно большое описание. Начнем с простого. Её можно использовать для итераций вообще безо всяких дополнительных церемоний. Для выхода из цикла воспользуйтесь функцией =return=.

<src lang="emacs-lisp">
(let ((a 0) s)   
   (loop     
     (if (< a 10)
         (progn
           (setq s (concat s (number-to-string a)))     
           (setq a (1+ a)))
          (return)))   
   (message s))
</src>

Также, как и =dolist=, макрос =loop= можно применить для итерации по списку.
<src lang="emacs-lisp">
(let ((a 0) s)
    (loop for x in '(0 1 2 3 4 5 6 7 8 9) do 
      (setq s (concat s (number-to-string x))))   
    (message s))
</src>

По двум спискам одновременно:
<src lang="emacs-lisp">
(let ((a 0) s)   
   (loop for x in '(0 1 2)
         for y in '("a" "b" "c")     
         do (setq s (concat s (concat (number-to-string x) y))))   
   (message s))
</src>

В отличие от двух вложенных циклов =for= в java, здесь итерация по спискам проходит одновременно. Поэтому результат выполнения приведенного кода будет "0a1b2c". Если на вход заданы списки разной длины, то итерация будет происходит по длине наименьшего.

Следующий пример показывает еще один способ использования =loop=:
<src lang="emacs-lisp">
(loop for x from 1 to 5       
      for y = (* x 2)
      collect y)
</src>

Результат выполнения этого кода: =(2 4 6 8 10)=.

** Работа со списками

Пара из двух элементов создается функцией =cons=. Первый элемент пары можно получить функцией =car=, второй -- =cdr=.
<src lang="emacs-lisp">
(setq a (cons 1 2))  ; ‘(1 2)
(car a)                     ; 1
(cdr a)                     ; 2
</src>

Список из нескольких элементов создается при помощи кобинации пар. Например:
<src lang="emacs-lisp">
(cons 1 (cons 2 (cons 3 nil)))
</src>

Такая запись для большого числа аргументов неудобна; на замену ей существует функция =list=:
<src lang="emacs-lisp">
(list 1 2 3)
</src>

Третий способ записать список -- при помощи кавычки: 
<src lang="emacs-lisp">
'(1 2 3)
</src>

Добавить еще один элемент к началу списка можно при помощи функции =cons=:
<src lang="emacs-lisp">
(cons 0 (list 1 2 3))  ; '(0 1 2 3)
</src>

Длину списка вычислит функция =length=:
<src lang="emacs-lisp">
(length '(1 2 3)) ; 3
</src>

N-й элемент списка вычисляет функция =nth=:
<src lang="emacs-lisp">
(nth 3 '(1 2 3 4 5 6))  ; 4
</src>

N-й cdr -- функция =nthcdr=:
<src lang="emacs-lisp">
(nthcdr 3 '(1 2 3 4 5 6))  ; '(4 5 6)
</src>

Первую ячейку списка можно изменить при помощи =setcar=:
<src lang="emacs-lisp">
(setq a '(1 2 3))
(setcar a 0)         ; a теперь содержит '(0 2 3)
</src>

Аналогично для =cdr=:
<src lang="emacs-lisp">
(setq a '(1 2 3))
(setcdr a '(4 5)) ; a  теперь содержит '(1 4 5)
</src>

; TODO: тут лучше использовать setf!
Для того, чтобы изменить n-й член списка, необходимо скомбинировать несколько функций:
<src lang="emacs-lisp">
(setq a '(1 2 3 4 5))
(setcdr a '(4 5))
(setcar (nthcdr 2 a) 7)  ; a теперь содержит '(1 2 7 4 5)
</src>

** Ввод-вывод

Для того, чтобы вывести строку в минибуфер[13], необходимо воспользоваться функцией =message=.

Для преобразования числа в строку предназначена функция =number-to-string=, строку в число -- =string-to-number=.

Ввод данных из минибуфера осуществляется при помощи функции =read-string=:
<src lang="emacs-lisp">
(read-string  "<приглашение>" "<значение-по-умолчанию>")
</src>

Пример:
<src lang="emacs-lisp">
(let (a)
  (setq a (string-to-number (read-string">> ""5")))
  (message (number-to-string (+ a 2))))
</src>

Если в Emacs установлен пакет IDO, то удобно пользоваться функцией =ido-completing-read=:
<src lang="emacs-lisp">
(ido-completing-read "<приглашение>" <список-вариантов> nil <t or nil>)
</src>

Первый параметр -- строка приглашения. Работает также, как и в =read-string=. Второй параметр -- список вариантов на выбор. Третий параметр здесь всегда =nil= и используется для совместимости с функцией =completing-read=. Четвертый параметр указывает, должна ли функция =ido-completing-read= требовать точное соответствие введенного текста с одним из вариантов. Например:
<src lang="emacs-lisp">
(message (ido-completing-read">> " '("One""Two""Three") nil t))
</src>

* Примеры elisp-скриптов

В этой части пособия мы рассмотрим несколько примеров решения реальных задач  с применением elisp. Для понимания материала очень желательно начальное знакомство с Emacs и любым Lisp-ом. Все elisp-функции, использованные в примерах, а также некоторые другие, будут подробно разобраны в последней части -- справочнике наиболее часто употребляемых функций.

** Импорт Java класса в программе на Clojure

*** Описание проблемы

При разработке программ на Clojure c применением библиотеки Swing часто приходится импортировать классы вручную. Например, на рис.1 показано создание объекта JSlider. Для того, чтобы этот код заработал, необходимо импортировать класс javax.swing.JSlider, как это показано на рис.

[[images/image03.png]]
Создание объекта класса javax.swing.JSlider

Сложность, как обычно, заключается в банальной лени перемещать курсор от текущей позиции к началу файла и добавления этого класса в список импортируемых.

[[images/image04.png]]

Рис.2: Импорт класса javax.swing.JSlider

*** План решения

Необходимо разработать функцию =my-import= , которая запросит название импортируемого класса (функция =get-java-class-name= получает название класса под курсором), название пакета класса и добавит указанный класс в список импорта.

*** Код

<src lang="emacs-lisp">
(defun get-java-class-name () 
  (condition-case nil 
      (let* ((class-name-regex "\\([[:alpha:]][_$[:alnum:]]*\\)") 
             (class-name-regex-full (concat "(\\(" class-name-regex  
              "\\.\\|new[[:space:]]*"  class-name-regex 
              "\\)[[:space:])]")))
        (search-forward ")")
        (when (search-backward-regexp class-name-regex-full) 
          (or (match-string 2) (match-string 3))))
  (error "")))

(defun my-import (cname nsname) 
  (interactive 
   (let ((cname (read-string "Insert class: " 
                    (get-java-class-name))) 
         (nsname (read-string "Namespace: " "javax.swing"))) 
     (list cname nsname))) 
  (save-excursion 
   (beginning-of-buffer) 
   (search-forward-regexp (concat ":import \\[" nsname)) 
   (insert (concat " " cname))))
</src>

*** Описание решения

Строка 1 объявляет функцию =get-java-class-name= <span>, которая будет использоваться в команде =my-import= для запроса имени импортируемого java-класса.

В строках 2-10 реализована сложная конструкция =condition-case= Она имеет следующую структуру:
<src lang="emacs-lisp">
(condition-case = VAR BODYFORM &rest HANDLERS)
</src>

Здесь никаких переменных не объявляется, поэтому второй параметр -- =nil= Тело формы выполняет необходимые операции и возвращает значение -- это значение вернет и вся форма =condition-case= В случае, если во время выполнения тела формы произойдет ошибка (например, мы не найдем название класса), то управление перейдет к третьему параметру -- вызову функции =error=, которая вернет пустую строку). Таким образом, здесь функция =condition-case= работает примерно также, как и =try/catch= в Java.

В строке 3 создается часть паттерна регулярного выражения для имени класса, которое может включать все алфавитно-цифровые символы и знак подчеркивания.

В строке 4 создается полный паттерн регулярного выражения, позволяющего найти имя импортируемого класса как для формы =(JSlider.)=, так и для =(new JSlider)=. Созданный паттерн будет выплнять поиск для выражений вида "(ClassName.) | (new ClassName)". Соответственно, в регулярном выражении есть несколько групп матчинга. Первая группа матчинга будет соответствовать всему выражению вместе с символом "." или словом "new". Вторая группа -- найденный класс в =(ClassName.)=, третья -- найденный класс в =(new ClassName)=. 

В строке 8 проверяется, найдена ли нужная нам строка. Если да -- то возвращается найденное имя класса из второй или третьей группы матчинга (строка 9).

Строки 11-12 создают команду =my-import=

Строки 13-14 предложат ввести имя импортируемого класса. По-умолчанию будет предложено слово, на котором пользователь оставил курсор. Введенное имя класса будет сохранено в переменной =cname=

Строка 15 аналогичным образом запрашивает имя пакета, в котором находится импортируемый класс, и сохраняет в переменной =nsname=

Обратите внимание, что команда =my-import= является также и обыкновенной функцией, которая принимает два аргумента: имя класса (=cname=) и имя пакета (=nsname=). Вызов =interactive= передает интерпретатору Lisp-а эти два параметра в виде списка (=cname nsname=), если значения параметров не заданы пользователем при вызове =my-import=

Строка 17 сохраняет текущее положение курсора для того, чтобы после вызова функции =my-import= курсор вернулся на исходную позицию.

Строка 18 переводит указатель на начало буфера.

Строка 19 находит место, где импортируются другие классы из указанного пакета.

Строка 20 вставляет импортируемый класс в строку с импортом.

После всех операций указатель вернется на исходную позицию.

**Примечание**: это примерная версия такой функции -- она имеет несколько недостатков, например, она требует, чтобы директива =(:import [nsname ..]=  уже была в тексте, но это тоже можно реализовать с помощью elisp.

** Генерация аксессоров в классе Java

*** Описание проблемы

Приватные члены класса необходимо сделать доступными извне при помощи геттеров/сеттеров (аксессоров). 

Eclipse и Netbeans неплохо справляются с этой задачей, но вставляют аксессоры в неподходящие места файла. Поэтому, сгенерированные функции приходится вручную переносить туда, где им следует быть.

*** План решения

Необходимо разработать функцию =my-accessor= <span>, создаст аксессоры для переменной, на которую указывает курсор (рис. 3).

[[images/image05.png]]

Рис. 3: Генерация аксессоров

*** Код

<src lang="emacs-lisp">
(defun my-accessor ()
  (interactive)
  (save-excursion
    (let* ((word (current-word))
           (upcased (capitalize word))
           (type 
             (progn (backward-word)
                    (let ((w2 (current-word)))
                    (if (string= word w2)
                        (progn 
                          (backward-word) 
                          (current-word))
                        w2)))))
     (beginning-of-buffer)
     (search-forward "// Accessors")
     (insert (concat "\n\tpublic " type " get"
                 upcased "(){\n\t\treturn "
                 word ";\n\t}\n"))
     (insert (concat "\tpublic void set" upcased
                 "(" type " " word ") {\n\t\t"
                 "this." word " = " word ";\n\t}")))))
</src>

*** Описание решения

Строки 1-2 объявляют команду =my-accessor=

В строке 3 сохраняется текущее положение курсора. После выполнения команды =my-accessor=, оно будет восстановлено.

В строке 4 объявляются локальные переменные. Переменная =word= при помощи функции =current-word= получит слово, на котором находится курсор. Переменная =upcased= получит значение слова с заглавной первой буквой (нужно будет для названия аксессора). Переменная =type= зарезервирована для типа члена класса.

Строка 7 установит курсор на предыдущее слово.

Строки 8-13 получат название класса. Код здесь сложный потому, что если изначально курсор стоит в середине имени члена класса, то =backward-word= вернет курсор к началу этого слова, а не на предыдущее слово. Поэтому в строке 9 проверяется, является ли скопированное слово названием идентификатора. Если да, то переместить курсор на еще одно слово влево и скопировать предыдущее, т.е. тип члена класса.

Строка 14 переводит курсор на начало буфера.

Строка 15 установит курсор за найденной строкой «// Accessors».

Строки 16-21 вставят текст аксессоров.

** Генерация и инициализация полей Java-класса в Android-приложении 

**** Описание проблемы

При разработке формы на Java под Android приходится редактировать два файла: описание UI в формате XML, и java-код, отвечающий за логику приложения.

Каждый элемент управления, описанный в xml-файле, необходимо соответствующим образом описать в java-классе. Для каждого элемента необходимо создать приватное поле и проинициализировать его в методе onCreate(). 

На рис. 4 показано описание формы в xml и выделен элемент wifiInfo класса TextView. Необходимо объявить приватный член TextView wifiInfo класса WiFiDemoActivity и присвоить ему значение, как это показано на рис.4.

Проблема заключается в том, что если элементов на форме много, то такой ручной труд быстро наскучивает. Необходимо его автоматизировать.

[[images/image06.png]]

Рис.4: Генерация полей java-класса по описанию формы в xml

*** План решения

Будут разработаны три функции. Функция =my-xml-buffer= запросит название xml-буфера (по-дефолту предложит название активного буфера). Аналогичным образом функция =my-java-buffer= запросит название буфера с java-классом (по-дефолту также предложит название активного буфера). Функция =my-widget= извлечет идентификатор элемента и его класс из xml-тега, создаст в java-классе приватный член (после комментария «// Members»)" и проинициализирует его (после комментария «// Initialize»)".

*** Код

<src lang="emacs-lisp">
(defun my-xml-buffer (buf-name)
  (interactive "BName of the xml buffer: ")
  (setq xml-buffer buf-name))

(defun my-java-buffer (buf-name)
  (interactive "BName of the java buffer: ")
  (setq java-buffer buf-name))

(defun get-widget-class-name ()
  "Returns class name for current widget"
  (let (a)
    (forward-char 1)
    (search-backward "<")
    (forward-char 1)
    (setq a (point))
    (search-forward-regexp "[ \n]")
    (backward-char 1)
    (buffer-substring-no-properties a (point))))

(defun get-widget-id ()
  "Returns ID for current widget"
  (let (a)
    (search-forward "android:id=\"@+id/")
    (setq a (point))
    (search-forward "\"")
    (backward-char 1)
    (buffer-substring-no-properties a (point))))

(defun get-widget-info ()
  "Returns info about current widget"
  (save-excursion
    (with-current-buffer xml-buffer
      (list (get-widget-class-name) (get-widget-id)))))

(defun my-widget ()
  (interactive)
  (let* ((wi (get-widget-info))
	 (class-name (car wi))
	 (element-id (cadr wi)))
    (with-current-buffer java-buffer
      (beginning-of-buffer)
      (search-forward-regexp "// Members")
      (insert (concat "\n\tprivate " class-name " " element-id ";"))
      (search-forward-regexp "// Initialize") 
      (insert (concat "\n\t\t" element-id " = (" 
		      class-name ")findViewById(R.id." element-id ");")))))
</src>


*** Описание решения

Строки 1-6 создают две функции =my-xml-buffer= и =my-java-buffer=. Это интерактивные функции (команды), которые принимают на вход один аргумент. Если вы вызываете эти функции из других функций -- то сами передадите этот аргумент. Если же запускаете их при помощи =M-x=, то аргумент функции передаст вызов =interactive= Например, в строке 2 аргументом вызову =interactive= служит текст "BName of the xml buffer: ". Это означает, что Emacs выведет приглашение "Name of the xml buffer: " и предложит ввести строку, которая должна быть именем буфера (существующего или нового). Символ "</span> =B= <span>" вначале строки означает, что по-умолчанию будет введено имя активного буфера.

Таким образом, функции =my-xml-buffer= и =my-java-buffer= позволяют установить глобальные переменные =xml-buffer= и =java-buffer=

Строки 7-16 создают функцию =get-widget-class-name= Эта функция умеет найти первую левую угловую скобку и скопировать первое слово за ней. Это слово -- имя класса виджета.

Строка 11 перемещает курсор на первую левую угловую скобку.

Строка 12 перемещает курсор на первое слово за этой скобкой.

Строка 13 сохраняет в локальной переменной =а= текущую позицию курсора.

Строка 14 установит курсор на первый символ после имени класса.

Строка 15 установит курсор на последний символ имени класса.

Строка 16 скопирует и вернет текст между =а= и текущей позицией, т.е. название класса виджета.

В строках 17-24 создается функция =get-widget-id=, которая аналогичным образом находит, копирует и возвращает id виджета.

Строки 25-29 создают функцию =get-widget-info= Эта функция, сохранив текущую позицию курсора (строка 27) в буфере с xml-файлом (строка 28) ищет класс и id виджета и возвращает эти две строки в виде списка (строка 29).

Строки 30-41 создают команду =my-widget= В локальную переменную =wi= записывается список из двух элементов: класс и id виджета.

Локальная переменная =class-name= получает имя класса, а =element-id= -- id виджета.

Строки 35-36 переводят курсор на начало java-буфера.

Строка 37 установит курсор сразу за комментарием "// Members".

Строка 38 вставит определение члена класса с заданными типом и названием переменной.

Строка 39 установит курсор сразу за комментарием "// Initialize".

Строки 40-41 вставят код инициализации новой переменной.

** Преобразование html-файла в haml-формат

*** Описание проблемы

В Ruby on Rails большой популярностью пользуется Haml для описания шаблонов web-страниц. Но преобразование html-страницы, полученной от дизайнера, в haml-формат требует немалой ручной работы (рис. 5).

[[images/image01.png]]

Рис. 5: Html-файл и его haml-аналог

*** План решения

Необходимо разработать функцию =html->haml=, которая преобразует html в haml. В случае отформатированной html-страницы это делается довольно просто. Во-первых, необходимо удалить все закрывающие теги. Во-вторых, открывающие теги =<tag>= заменить на их haml-аналоги: =%tag=. В-третьих, удалить все пустые строки.

*** Код

<src lang="emacs-lisp">
(defun html->haml ()
  (interactive)
  (let* ((str (buffer-substring 
	       (point-min) (point-max))))
    (kill-region (point-min) (point-max))
    (insert 
     (replace-regexp-in-string "^[ ]*\n" ""
	(replace-regexp-in-string "<\\(.+\\)>" "%\\1 "
	   (replace-regexp-in-string "</.+>" "" str))))))
</src>

*** Описание решения

В строках 1-2 создается команда =html->haml=

Строки 3-4 создают локальную переменную =str=, в которую скопирован весь буфер (т.е. текст с минимальной по максимальную позицию курсора).

Строка 5 удаляет весь текст в буфере.

Строки 6-9 вставляют в буфер результат выполнения трех подстановок по регулярным выражениям: вначале строка 9 удаляет все закрывающие теги из str; затем строка 8 заменяет все открывающие теги =<tag>= на их haml-аналоги =%tag=; и в конце строка 7 удаляет все пустые строки.

** Создание конструктора для неизменяемых объектов

*** Описание проблемы

В последнее время идеи функционального программирования всё больше и больше проникают в мейнстримные языки. Так, например, в java нередко используются классы неизменяемых объектов. Все поля неизменяемого объекта устанавливаются в конструкторе и дальше  не могут быть изменены (рис. 6).

На изображении представлен класс WifiPoint, у которого четыре поля. Эти поля должны быть установлены в конструкторе, а сам конструктор вручную пишется по технологии copy/paste. Этот ручной copy/paste нужно автоматизировать.

[[images/image00.png]]

Рис. 6: Класс для неизменяемого объекта

*** План решения

Необходимо разработать функцию =my-constructor=, которая, во-первых, распарсит класс (получит его имя и определения полей), и, во-вторых, создаст конструктор на основе полученной информации.

*** Код

<src lang="emacs-lisp">
(defun my-constructor ()
  (interactive)
  (save-excursion
    (let (cname type name (res ‘()) params)
      (search-backward-regexp "class ")
      (forward-char 7)
      (setq cname (current-word))
      (loop
       (if (equal nil (search-forward "public final " nil t))
	   (return))
       (setq type (current-word))
       (forward-word)
       (forward-char 1)
       (setq name (current-word))
       (add-to-list ‘res (cons type name)))
      (search-forward-regexp "\n")
      (dolist (var res)
	(setq params (concat params (car var) " " (cdr var) ", ")))
      (setq params (substring params 0 (- (length params) 2)))
      (insert (concat "\n\t public " cname "(" params ") {\n"))
      (dolist (var res)
	(insert (concat "\t\tthis." (cdr var) " = " (cdr var) ";\n")))
      (insert "\t}\n"))))
</src>

*** Описание решения

Строки 1-2 создают интерактивную функцию =my-constructor=

Строка 3 сохраняет исходную позицию курсора затем, чтобы после выполнения функции вернуть курсор на место.

Строка 4 создает несколько локальных переменных: =cname= для имени класса, =type= для типа поля класса, =name= для имени поля класса, =res= -- накапливающий параметр, который будет хранить списки из двух элементов: =type= и =name=; =params= будет хранить строку параметров будущего конструктора.

Строки 5-6 устанавливают курсор на первый символ имени класса.

Строка 7 копирует имя класса в переменную =cname=

Строки 8-15 ищут все определения полей класса.

Строки 9-10 проверяют, остались ли еще определения полей класса. Если нет -- цикл заверишается.

Строки 11-14 копируют в переменные =type= и =name= тип и имя найденного поля класса.

Строка 15 добавляет в список =res= еще один элемент: список из =type= и =name= Таким образом, когда цикл закончится, в переменной =res= будет информация обо всех полях класса.

Строка 16 переводит курсор на первый символ после последнего определения поля класса. Сюда можно вставлять определение конструктора.

Строки 17-18 описывают параметры конструктора. В цикле =dolist= переменная =var= будет принимать значение очередного описания поля класса (т.е. списка из =type= и =name=). Тип и имя аргумента конструктора вместе с запятой и пробелом добавляются к переменной =params= Поэтому, в конце, после всех конкатенаций, необходимо удалить последние два символа: лишнюю запятую и пробел (строка 19).

Строка 20 вставляет определение конструктора.

Строки 21-22 в цикле проинициализируют поля класса.

Строка 23 закроет тело конструктора.

**Примечание**: Такой "ручной" парсинг класса хорош исключительно для небольших задач "для себя". Если нужно реализовать более надежный способ парсинга и генерации кода, необходимо воспользоваться возможностями пакета CEDET, в частности инструментами Semantic и SRecode.

* Справочник часто употребимых функций

** Перемещение курсора и получение позиции

*** Группа функций point-

 - =point= -- текущее значение указателя.
 - =point-min= -- минимально возможное значение указателя.
 - =point-max= -- максимально возможное значение указателя.

Функции возвращают значение в виде числа символов от начала буфера, начиная с *единицы*.

Пример:
<src lang="emacs-lisp">
(point-min)        ;; Вернет 1
</src>

*** goto-char

Перемещает курсор на заданную позицию. Формат вызова:
<src lang="emacs-lisp">
(goto-char POSITION)
</src>

Здесь POSITION -- номер символа или маркер.

Пример:
<src lang="emacs-lisp">
(goto-char 1)                 ; Переместить в начало буфера
(goto-char (point-max))  ; Переместить в конец буфера
</src>


*** line-number-at-pos

Вернет номер строки, на которой стоит курсор. Формат вызова:
<src lang="emacs-lisp">
(line-number-at-pos &optional POS)
</src>

Необязательный параметр POS -- номер символа в буфере, для которого необходимо найти номер строки.

Пример:
<src lang="emacs-lisp">
(line-number-at-pos)                  ; Вернет номер текущей строки
(line-number-at-pos (point-min)) ; Вернет 1
</src>

*** current-column

Вернет номер символа в строке, на котором стоит курсор. Значения начинаются с *нуля*. Пример:
<src lang="emacs-lisp">
(current-column)
</src>

*** Группа функций beginning-of-/end-of-

Эти функции перемещают курсор на определенную позицию:
 - =beginning-of-line= -- на начало строки;
 - =end-of-line= -- на конец строки;
 - =beginning-of-buffer= -- в начало буфера;
 - =end-of-buffer= -- в конец буфера.

Пример:
<src lang="emacs-lisp">
(beginning-of-line)
</src>

** Регион/Выделение текста

*** region-active-p

Возвращает true если включен режим показа выделения (transient mark) и текст выделен.

Пример:
<src lang="emacs-lisp">
(if (region-active-p) 
    (message "Text marked")  
(message "Text not marked"))
</src>

*** Группа функций region-

 - =region-beginning= -- возвращает номер символа, на котом начинается выделение.
 - =region-end= -- возвращает номер символа окончания выделения.

Пример:
<src lang="emacs-lisp">
(region-beginning)
(region-end)
</src>

*** kill-region

Вырезает часть текста между указанными номерами символов. Формат вызова:
<src lang="emacs-lisp">
(kill-region BEG END)
</src>

Пример:
<src lang="emacs-lisp">
; Удалит выделенный фрагмент текста
(kill-region (region-beginning) (region-end)) 
</src>
      
*** kill-ring-save

Данная функция аналогична =kill-region= за исключением того, что не вырезает, а только копирует текст.

*** Группа функций forward-/backward-

 - =forward-char= -- перемещает курсор на один символ вправо.
 - =forward-word= -- перемещает курсор на одно слово вправо.
 - =forward-line= -- перемещает курсор на одну строку вниз.
 - =backward-char= -- перемещает курсор на один символ влево.
 - =backward-word= -- перемещает курсор на одно слово влево.
 - =backward-line= -- перемещает курсор на одну строку вверх.

Пример:
<src lang="emacs-lisp">
(forwar-word)
(backward-char)
</src>

*** Группа функций search-

 - =search-forward= -- функция ищет указанный текст вправо от курсора
 - =search-backward= -- функция ищет указанный текст влево от курсора
 - =search-forward-regexp= -- функция ищет указанное регулярное выражение вправо от курсора
 - =search-backward-regexp= -- функция ищет указанное регулярное выражение вправо от курсора

Формат вызова:
<src lang="emacs-lisp">
(search-forward STRING &optional BOUND NOERROR COUNT)
</src>

=STRING= -- текст для поиска.

Остальные параметры -- необязательные:
 - =BOUND= -- ограничитель поиска (номер символа в буфере, после которого поиск производиться не будет). Если параметр равен =nil= (по умолчанию), то поиск производится до конца буфера.
 - =NOERROR= -- если =t=, то в случае безуспешного поиска функция просто вернет =nil=. Иначе -- установит курсор на последний просмотренный символ и вернет =nil.=
 - =COUNT= -- количество повторений поиска при успехе.

Функции =search-backward=, =search-forward-regexp=, =search-backward-regexp= имеют идентичный формат вызова. Чуствительность к регистру при поиске определяется глобальной переменной =case-fold-search=

Пример:
<src lang="emacs-lisp">
(search-forward "My search text")
(setq case-fold-search nil) ;; TODO: it's better to not change it globally!
(search-backward "MY SEARCH TEXT")
</src>

** Работа с буфером

*** buffer-name</span></h3>

Возвращает имя буфера в виде строки. Формат вызова
<src lang="emacs-lisp">
(buffer-name &optional BUFFER)
</src>

Если вызвана без параметров, то вернет имя активного буфера.  Если в функцию передан буфер, то вернет имя указанного буфера.

Пример:

<src lang="emacs-lisp">
(buffer-name)        ;; Вернет =*scratch*=
</src>

*** buffer-list</span></h3>

Вернет список всех буферов. Внимание: в списке будут объекты-буфера, а не их текстовые названия. Для получения имени такого буфера воспользуйтесь функцией =buffer-name=. Формат вызова:
<src lang="emacs-lisp">
(buffer-list &optional FRAME)
</src>

Вызванная без параметров, вернет список буферов активного фрейма. Если передать в функцию объект фрейма, то вернет список буферов для этого фрейма.

Пример:
<src lang="emacs-lisp">
(buffer-list)  ;; Вернёт (#<buffer *scratch*> 
               ;; #<buffer  *Minibuf-1*> #<buffer *Help*>)
</src>

*** with-current-buffer

Выполняет указанные действия в заданным буфере. Возвращает значение, которое вернет последняя вызванная в теле функция. Формат вызова:
<src lang="emacs-lisp">
(with-current-buffer BUFFER-OR-NAME &rest BODY)
</src>
 - =BUFFER-OR-NAME= -- объект буфера или его имя.
 - =BODY= -- вызовы функций, которые нужно выполнить в заданном буфере.

Пример:
<src lang="emacs-lisp">
(with-current-buffer "*scratch*"
  (insert "Hello!"))
</src>

*** switch-to-buffer

Переключает окно на указанный буфер и возвращает объект этого буфера. Формат вызова:
<src lang="emacs-lisp">
(switch-to-buffer BUFFER-OR-NAME &optional NORECORD FORCE-SAME-WINDOW)
</src>

 - =BUFFER-OR-NAME= -- буфер, его название или nil. Если передан буфер или его название, то переключает на указанный буфер. Если nil -- то переключает на буфер, который укажет функций.

Необязательные параметры.
 - =NORECORD= -- если не nil, то эта функция не будет помещать указаннй буфер в начало списка буферов и не сделает окно, отображающее буфер, последним выбранным.
 - =FORCE-SAME-WINDOW= -- если nil, то выбранный буфер может быть отображен в любом окне. Иначе -- отобразить в активном окне или выдать ошибку.

Пример:
<src lang="emacs-lisp">
(switch-to-buffer "*scratch*")
</src>

*** current-word

Вернет слово или символ в виде строки, на котором находится курсор. Формат вызова:
<src lang="emacs-lisp">
(current-word &optional STRICT REALLY-WORD)
</src>

Необязательные параметры:
 - =STRICT= если не-=nil=, то функция вернет =nil= только если курсор не на (или рядом) слове или символе.
 - =REALLY-WORD= если не =nil=, то просто находит слово. (обычно функция ищет символ).

Пример:
<src lang="emacs-lisp">
(setq my-word (current-word))
</src>

*** insert

Вставит указанную строку или набор символов в буфер на позиции курсора. Формат вызова:
<src lang="emacs-lisp">
(insert &rest ARGS)
</src>

 - =ARGS= -- набор строк или символов.

Пример:
<src lang="emacs-lisp">
(insert "Hello, World!")
</src>

*** count-lines

Посчитает количество строк между указанными номерами символов. Формат вызова:
<src lang="emacs-lisp">
(count-lines START END)
</src>

=START= и =END= -- номера символов в буфере, между которыми необходимо посчитать количество строк.

Пример:
<src lang="emacs-lisp">
(count-lines 5 17)
</src>

*** find-file

Откроет буфер с указанным файлом. Если такого буфера еще нет, то создаст его, загрузит  файл и сделает буфер активным. Формат вызова:
<src lang="emacs-lisp">
(find-file FILENAME &optional WILDCARDS)
</src>

 - =FILENAME= -- путь к файлу.

Необязательный параметр:
 - =WILDCARDS= -- если не nil и содержит шаблон имени файла, то по указанному пути откроет все файлы, подходящие под заданный шаблон.

Пример:
<src lang="emacs-lisp">
(find-file "~/text.txt")
</src>

*** delete-and-extract-region

Удалить текст между указанными символами и вернуть его. Формат вызова:
<src lang="emacs-lisp">
(delete-and-extract-region START END)
</src>

Удалит текст между символами с номерами =START= и =END= и вернет этот текст. Пример:
<src lang="emacs-lisp">
(delete-and-extract-region 10 17)
</src>

** Прочее

*** save-excursion

Cначала сохраняет данные о текущей точке, метке и текущем буфере, затем выполняет выражения заданные в BODY, и после завершения работы, восстанавливает значения сохраненных переменных.  Эту функцию рекомендуется применять когда вы изменяете текущую позицию в буфере, или переключаетесь в другой буфер, и т.д.

Формат вызова: =(save-excursion BODY)=

Пример:
<src lang="emacs-lisp">(save-excursion 
  (beginning-of-line))
</src>

*** Группа функций completing-read/ido-completing-read

Предлагают пользователю ввести текст при помощи автодополнения. Формат вызова обеих функций одинаковый.
 - =completing-read= -- функция входит в стандартную поставку Emacs.
 - =ido-completing-read= -- функция доступна в пакете IDO.

Формат вызова:
<src lang="emacs-lisp">
(completing-read PROMPT COLLECTION &optional PREDICATE REQUIRE-MATCH INITIAL-INPUT HIST DEF INHERIT-INPUT-METHOD)
</src>

 - =PROMPT= -- строка приглашения, которая будет показана пользователю;
 - =COLLECTION= -- список строк для автодополнения.

Необязательные параметры:
 - =PREDICATE= -- функция-предикат, которая отфильтрует, какие элементы =COLLECTION= показывать при автодополнении. В =ido-completing-read= этот параметр игнорируется и присутствует только для совместимости с =completing-read=
 - =REQUIRE-MATCH= может принимать одно из следующих значений:
   - =t= -- означает, что функция не завершится до тех пор, пока пользователь не введет текст, совпадающий с одним из элементов коллекции, или пустую строку.
   - =nil= -- означает, что пользователь может ввести любой текст, как совпадающий, так и не совпадающий с предложенными вариантыми из COLLECTION.
   - =confirm-after-completion= -- значит, что можно ввести любой текст, даже не совпадающий с предложенными вариантами, но пользователь должен будет подтвердить свой ввод.
   - что угодно, кроме t, ведет себя также, как с параметром t, только не разрешает вводить пустую строку.
 - =INITIAL-INPUT= -- устаревшая опция, не рекомендуется для использования. Если передана строка, то эта строка будет значением по умолчанию.
 - =HIST= -- список с "историей" введенных значений.
 - =DEF= -- значение по умолчанию.

Пример:
<src lang="emacs-lisp">
(completing-read ">>" '("111" "122" "133"))
</src>

* Дополнительная информация

** Пакеты для разработчика

Поскольку Emacs разрабатывался разработчиками для разработчиков, то он поддерживает почти все существующие языки программирования, а также утилиты, такие как контроль версий, различные чекеры и т.п. (достаточно полный список можно найти на [[http://emacswiki.org][EmacsWiki]]). Например (почти все пакеты можно установить через менеджер пакетов или через el-get):
 - CC-Mode (включен в Emacs) -- пакет для редактирования кода на C/C++/Objective-C/Java/Pike/AWK
 - Lisp mode (включен в Emacs) -- для редактирования кода на разных вариантах Lisp
 - SLIME -- де-факто стандарт для разработки на Common Lisp, Clojure и Scheme -- реализует интерактивную разработку
 - [[http://alexott.net/ru/writings/emacs-devenv/EmacsCedet.html][CEDET]] -- набор пакетов для работы с исходным кодом на разных языках. Включает навигацию по коду, дополнение имен (для некоторых режимов) и т.п.
 - yasnippet -- реализует поддержку разворачиваемых шаблонов
 - ensime -- пакет для интерактивной работы со Scala
 - [[http://alexott.net/ru/writings/emacs-devenv/EmacsErlang.html][erlang-mode и distel]] -- пакеты для работы с кодом на Erlang
 - haskell-mode -- пакет для работы с кодом на haskell
 - paredit -- незаменимый пакет для работы с Lisp-like языками
 - [[https://github.com/espenhw/malabar-mode][malabar-mode]] -- улучшенный режим для работы с кодом на Java, с поддержкой Maven и т.п.

Для работы с системами контроля версий, имеется [[http://alexott.net/ru/writings/emacs-vcs/][огромное количество пакетов]], которые позволяют эффективно использовать эти системы не покидая Emacs, и при необходимости перезагружать измененные файлы и т.п.

** Другие полезные пакеты

 - tramp (включен в Emacs) -- реализует удаленный доступ к файлам используя разные методы доступа -- ssh, ftp, sudo и т.д.
 - org-mode (включен в Emacs) -- мощная смесь органайзера, TODO и Wiki. Множество расширений, в том числе и для literate programming
 - AUCTeX, сотоварищи -- очень мощный пакет для писания документов с помощью TeX/LaTeX/...

** Литература

 - "An Introduction to Programming in Emacs Lisp", R.J.Chassel, 3rd edition, GNU Press, 2009.
 - "GNU Emacs Lisp Reference Manual", B.Lewis, D. LaLiberte, R.Stallman and others, 3rd edition, Free Software Foundation, 2010.
 - "Writing GNU Emacs Extensions", B.Glickstein, O'Reilly, 1997
 - [[http://alexott.net/ru/emacs/elisp-intro/elisp-intro-ru.html][Перевод Emacs Lisp Intro]]
 - [[http://alexott.net/ru/emacs/emacs-manual/emacs_toc.html][Перевод Emacs Manual для версии 20.x]]
 - [[http://emacswiki.org][Emacs Wiki]]
 - [[http://planet.emacsen.org][Агрегатор новостей об Emacs]] и [[http://planet.emacsen.org/ru/][его русская версия]]

Footnotes:  
[1] Символ чем-то похож на "переменные" в других языках программирования. Подробнее о символах читайте дальше.

[2] Это синтаксический сахар для специальной формы =quote=.

[3] Emacs компилирует исходный код в байт-код, который потом выполняется. 

[4] Этот буфер не связан с файлом на диске, так что при выходе из редактора, его содержимое не будет сохранено.

[5] Этот метод запуска работает только для интерактивных функций. Если вам нужно вызвать неинтерактивную функцию, то вы можете воспользоваться сочетанием клавиш =M-:= и ввести нужное выражение в минибуфере.

[6] Ассоциативные списки хороши для небольших объемов данных, но если вам нужно хранить много данных, то лучше воспользоваться хеш-таблицами.

[7] Сюда относятся =defvar=, =defconst=, =defun=, =defmacro=.

[8] Одним из преимуществ использования =defvar= & =defconst= является возможность добавления документации к символу.

[9] Этот пример может быть записан как =(setq a 17 s "Hello!")=, поскольку =setq= принимает список пар символ/значение.

[10] Также есть более общая функция setf, которая умеет присваивать значения ссылкам, например, элементам списка.

[11] Вызов =(interactive)= здесь нужен только для запуска функции с помощью =M-x=. Если ваша функция не будет интерактивной, а будет использована из других функций или хуков, то =(interactive)= не нужен. То же самое справедливо и для других примеров.

[12] Есть также формы =prog1=, =prog2=, и т.д.

[13] Она также будет выведена в буфер =*Messages*=

